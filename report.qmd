---
title: "Our Money Report"
author: "Talisma Manuel"
date: today
date-format: report of DD MMMM, YYYY
format:
  pdf:
    df-print: kable
    typst:
        font-paths: ["fonts"]
        format: custom.typ
    color-links: true
    page-layout: full
    toc: true
    # toc-depth: 2
    geometry:
        - top=20mm
        - left=20mm
        - right=20mm
        - bottom=20mm
    include-in-header:
        text: |
           \usepackage{etoolbox}
           \pretocmd{\tableofcontents}{\clearpage}{}{}
           \apptocmd{\tableofcontents}{\clearpage}{}{}
    # number-sections: true
    keep-tex: true
    papersize: a4
    fontsize: 8pt
echo: false
error: false
warning: false
engine: jupyter
jupyter: python3
kernel: env
---
::: {.pagebreak}

```{python}
from dateutil.relativedelta import relativedelta
from scipy.interpolate import make_interp_spline
from IPython.display import display, Markdown
from datetime import datetime, timedelta
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import seaborn as sns 
import pandas as pd
import numpy as np
import calendar

#set the font
plt.rcParams["font.family"] = "Open Sans"

# Load and prepare the data
df = pd.read_excel("transactions.xlsx")
df['category'] = df['category'].str.lower().str.strip()
df['createdAt'] = pd.to_datetime(df['createdAt'], format='%d-%m-%Y')

def show(df):
    styled = (
        df.style
        .format(precision=2)
        .hide(axis='index')
        .set_table_styles([
            {'selector': 'thead',
             'props': 'background-color: #0077b6; color: white; font-weight: bold; padding: 6px;'}
        ])
        .set_table_attributes('style="border-collapse: collapse; border: 1px solid black; font-size: 14px;"')
    )
    return display(styled)


# Current date and month
now = datetime.now()
first_day_of_month = datetime(now.year, now.month, 1)

# Current month outcome transactions
current_month_outcomes = df[
    (df['type'] == 'outcome') &
    (df['createdAt'].dt.month == now.month) &
    (df['createdAt'].dt.year == now.year)
]

# Biggest expense category this month
category_sum = current_month_outcomes.groupby('category')['price'].sum()
if not category_sum.empty:
    biggest_category = category_sum.idxmax()
    biggest_value = category_sum.max()
    total_current_month = category_sum.sum()
    other = total_current_month - biggest_value
else:
    biggest_category = None
    biggest_value = 0
    total_current_month = 0
    other = 0

# Outcome in the last 6 months
six_months_ago = now - timedelta(days=180)
last_six_months_outcomes = df[
    (df['type'] == 'outcome') & 
    (df['createdAt'] >= six_months_ago)
]
total_last_six_months = last_six_months_outcomes['price'].sum()

# High expenses this month (> 1000)
high_expenses = category_sum[category_sum > 1000].reset_index()
high_expenses.columns = ['Categoria', 'Total']

def format_value_style(valor):
    """Formata número como 1.2K, 3.5M etc."""
    if abs(valor) >= 1_000_000_000:
        return f'{valor / 1_000_000_000:.1f}B'
    elif abs(valor) >= 1_000_000:
        return f'{valor / 1_000_000:.1f}M'
    elif abs(valor) >= 1_000:
        return f'{valor / 1_000:.1f}K'
    else:
        return f'{valor:.0f}'
```

## Gestao dos Gastos

:::: {layout-ncol="2"}

### Onde estou gastando mais dinheiro?

```{python}
from matplotlib import font_manager

# Configurações globais de fonte
plt.rcParams['font.family'] = 'Open Sans'
plt.rcParams['font.size'] = 8

if biggest_category:
    labels = [biggest_category, 'Outros']
    sizes = [biggest_value, other]
    colors = ['#0077b6', '#90e0ef']

    fig, ax = plt.subplots(figsize=(6, 6))  # tamanho em polegadas (largura, altura)
    wedges, texts, autotexts = ax.pie(
        sizes,
        labels=labels,
        colors=colors,
        startangle=90,
        autopct='%1.1f%%',
        textprops={'fontsize': 11, 'fontfamily': 'Open Sans'}  # garante fonte no texto do gráfico
    )

    ax.set_title(
        f"Maior despesa de {now.strftime('%B/%Y')}",
        fontfamily='Open Sans',
        fontsize=11
    )

    plt.axis('equal')
    plt.show()
else:
    display("Nenhuma despesa registrada para o mês atual.")

```

<div>

### Quanto gastei no total nos ultimos meses?

```{python}
display(Markdown(f"Neste mês: **{total_current_month:,.2f}** \n Nos últimos 6 meses **{total_last_six_months:,.2f}**"))
```

### Quais foram minhas maiores despesas esse mes?

Categorias com gasto acima de 1000:


```{python}
if not high_expenses.empty:
   # Mostrar o DataFrame com as categorias e valores
   high_expenses
   show(high_expenses)
else:
    display(Markdown(f"Nenhuma categoria ultrapassou 1000 este mês."))

if biggest_category:
    display(Markdown(f"O maior gasto este mês foi em: **{biggest_category}** com **{biggest_value:,.2f}**"))
```

</div>

::::

:::

### Meu padrao de gasto mudou comprado ao meses anteriores ?

```{python}
import matplotlib.colors as mcolors

df_outcome = df[df['type'] == 'outcome'].copy()
# === Últimos 3 meses ===
now = pd.Timestamp.today()
months = [(now - relativedelta(months=i)) for i in range(2, -1, -1)]

# === Acumulador geral para filtrar categorias ===
category_totals = {}

for m in months:
    df_month = df_outcome[
        (df_outcome['createdAt'].dt.month == m.month) &
        (df_outcome['createdAt'].dt.year == m.year)
    ].copy()

    if df_month.empty:
        continue

    cat_sum = df_month.groupby('category')['price'].sum()
    for cat, val in cat_sum.items():
        category_totals[cat] = category_totals.get(cat, 0) + val

# Filtrar categorias com total > 0
categorias_ativas = [cat for cat, total in category_totals.items() if total > 0]

# === Tamanho dinâmico da figura baseado em número de categorias ===
cell_width = 1.0   # largura por coluna
cell_height = 1.0 # altura por linha
ncols = len(categorias_ativas)
nrows = 5  # número máximo de semanas por mês

fig_width = cell_width * ncols
fig_height = cell_height * nrows

# === Preparar os subplots (3 linhas) ===
fig, axes = plt.subplots(3, 1, figsize=(fig_width, fig_height * 3), constrained_layout=True)

plot_index = 0
for m in months:
    df_month = df_outcome[
        (df_outcome['createdAt'].dt.month == m.month) &
        (df_outcome['createdAt'].dt.year == m.year)
    ].copy()

    if df_month.empty or plot_index >= 3:
        continue

    df_month['semana'] = df_month['createdAt'].apply(lambda d: (d.day - 1) // 7 + 1)
    df_month = df_month[df_month['category'].isin(categorias_ativas)]

    pivot = df_month.pivot_table(
    index='semana',
    columns='category',
    values='price',
    aggfunc='sum',
    fill_value=0
    )

    # Garante todas as categorias ativas como colunas, mesmo que não tenham dados neste mês
    pivot = pivot.reindex(columns=sorted(categorias_ativas), fill_value=0)
    pivot = pivot.reindex(index=range(1, 6), fill_value=0)


    # Formatar os valores para anotações
    annotations = pivot.applymap(lambda v: format_value_style(v) if v != 0 else "")

    # Substituir 0 por NaN para que fiquem brancas no heatmap
    pivot_masked = pivot.replace(0, np.nan)

    # Criar um colormap baseado no YlOrRd
    cmap = sns.color_palette("YlOrRd", as_cmap=True)

    # Criar um mapa de cores com cor padrão para NaNs como 'beige'
    cmap = mcolors.ListedColormap(cmap(np.linspace(0, 1, 256)))
    cmap.set_bad(color='#f2f2f2')  # cor para os NaNs
    # Plotar
    sns.heatmap(
        pivot_masked,
        annot=annotations,
        fmt="",
        cmap=cmap,
        linewidths=0.5,
        linecolor='white',
        cbar=False,
        ax=axes[plot_index],
        annot_kws={"size": 14},
        mask=pivot_masked.isnull(),  # aplica máscara para que NaN não seja colorido
        square=False
    )

    axes[plot_index].set_title(f"Gastos semanais por categoria - {calendar.month_name[m.month]}/{m.year}", fontsize=14)
    axes[plot_index].set_xlabel("Categoria", fontsize=13)
    axes[plot_index].set_ylabel("Semana", fontsize=13)
    axes[plot_index].tick_params(axis='x', labelrotation=45, labelsize=11)
    axes[plot_index].tick_params(axis='y', labelsize=11)

    plot_index += 1

plt.suptitle("Resumo dos Gastos Semanais (últimos 3 meses)", fontsize=15)
plt.show()

display(Markdown(f"### Padrões nos meus gastos por semana"))

# Inicializar dicionário para armazenar presença por (semana, categoria)
week_category_presence = {}

for idx, m in enumerate(months):
    df_month = df_outcome[
        (df_outcome['createdAt'].dt.month == m.month) &
        (df_outcome['createdAt'].dt.year == m.year)
    ].copy()

    if df_month.empty:
        continue

    df_month['week'] = df_month['createdAt'].apply(lambda d: (d.day - 1) // 7 + 1)
    df_month = df_month[df_month['category'].isin(categorias_ativas)]

    for week, group in df_month.groupby('week'):
        active_cats = set(group['category'].unique())
        for cat in categorias_ativas:
            key = (week, cat)
            if key not in week_category_presence:
                week_category_presence[key] = [False, False, False]
            week_category_presence[key][idx] = cat in active_cats

# Montar matriz de padrões: True se a categoria esteve presente em todas as 3 vezes
pattern_matrix = pd.DataFrame(index=range(1, 6), columns=sorted(categorias_ativas), dtype=bool)

for (week, cat), presence_list in week_category_presence.items():
    if all(presence_list):
        pattern_matrix.loc[week, cat] = True
    else:
        pattern_matrix.loc[week, cat] = False

# Substituir NaNs por False para células inexistentes
pattern_matrix.fillna(False, inplace=True)

# Criar mapa de cores manualmente (True -> yellow, False -> light gray)
pattern_colors = pattern_matrix.applymap(lambda x: '#fff176' if x else '#f2f2f2')

# Criar nova figura
fig_pattern, ax_pattern = plt.subplots(figsize=(fig_width, fig_height))
sns.heatmap(
    np.ones_like(pattern_matrix, dtype=float),  # dummy data
    mask=False,
    annot=False,
    fmt="",
    cmap=mcolors.ListedColormap(['white']),  # dummy cmap (será substituído pelo facecolor)
    linewidths=0.5,
    linecolor='white',
    cbar=False,
    square=False,
    xticklabels=pattern_matrix.columns,
    yticklabels=pattern_matrix.index,
    ax=ax_pattern
)

# Pintar manualmente as cores das células
for y in range(pattern_matrix.shape[0]):
    for x in range(pattern_matrix.shape[1]):
        ax_pattern.add_patch(plt.Rectangle((x, y), 1, 1, facecolor=pattern_colors.iloc[y, x], edgecolor='white'))

# Títulos e rótulos
ax_pattern.set_title("Padrão de categorias ativas nas semanas (3 meses)", fontsize=14)
ax_pattern.set_xlabel("Categoria", fontsize=13)
ax_pattern.set_ylabel("Semana", fontsize=13)
ax_pattern.tick_params(axis='x', labelrotation=45, labelsize=11)
ax_pattern.tick_params(axis='y', labelsize=11)
```

### Existem despesas recorrentes nos simestre ?

```{python}
#| tbl-align: center
#| tbl-cap-location: top

# Definir as datas de corte
three_months_ago = now - relativedelta(months=3)
six_months_ago = now - relativedelta(months=6)

# Filtrar gastos (outcome) para os períodos
outcomes_3m = df[(df['type'] == 'outcome') & (df['createdAt'] >= three_months_ago)]
outcomes_6m = df[(df['type'] == 'outcome') & (df['createdAt'] >= six_months_ago)]

category_3m = (
    outcomes_3m.groupby('category')['price']
    .sum()
    .reset_index()
    .sort_values(by='price', ascending=True)
)

# Agrupar e calcular total e % para os últimos 6 meses
category_6m = (
    outcomes_6m.groupby('category')['price']
    .sum()
    .reset_index()
    .sort_values(by='price', ascending=True)
)

```

ultimo trimeste

```{python}
if not category_6m.empty:
    # Cria figura e eixo
    fig, ax = plt.subplots(figsize=(10, 8.5))
    bars = ax.barh(category_6m['category'], category_6m['price'], color='#0077b6', height=0.6 )

    # Estilo do gráfico
    ax.set_title('Despesas recorrente por Categoria - Último Semestre', weight='bold')
    ax.set_ylabel('Categoria')
    ax.tick_params(axis='y', which='major', labelsize=9.5)
    ax.tick_params(axis='x', labelbottom=False, bottom=False)
    #ax.grid(axis='x', linestyle='--', alpha=0.6)
    for spine in ['top', 'right', 'left', 'bottom']:
        ax.spines[spine].set_visible(False)

    # === Adiciona labels formatados ao final de cada barra ===
    for bar in bars:
        width = bar.get_width()
        label = format_value_style(width)
        ax.text(
            width + 100,  # desloca levemente à direita da barra
            bar.get_y() + bar.get_height() / 2,  # centraliza verticalmente
            label,
            va='center',
            ha='left',
            fontsize=8,
            color='#0077b6',
        )

    plt.tight_layout()
    plt.show()
else:
    display("Nenhuma despesa registrada nos últimos 6 meses.")
```

### Como meus gastos em evoluíram ao longo do tempo?

```{python}
#| fig-align: center

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns

def plot_category(categoria, dados, cor, figsize=(6, 2.5)):
    """Plota gráfico de barras e linha para uma categoria com valores compactos."""
    dados = dados.sort_values('month')
    x = dados['month']
    y = dados['price']

    fig, ax = plt.subplots(figsize=figsize)

    # Gráfico de barras (com cor mais transparente)
    ax.bar(x, y, color=cor, alpha=0.7, width=20, label='Barras')

    # Gráfico de linhas sobreposto
    #ax.plot(x, y, color=cor, linewidth=1, marker='o', markersize=2, linestyle='--', label='Linha')

    # Anotações nos pontos
    for xi, yi in zip(x, y):
        ax.annotate(format_value_style(yi),
                    xy=(xi, yi), xytext=(0, 5), textcoords='offset points',
                    ha='center', fontsize=6, color=cor)

    ax.set_title(f'Gastos: {categoria.capitalize()}', size=8)
    ax.set_ylim(bottom=0, top=ax.get_ylim()[1] * 1.1)
    
    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=1))
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%b-%Y'))
    ax.tick_params(axis='x', rotation=45, labelsize=6)
    ax.tick_params(axis='y', labelsize=6)

    # Estética
    ax.spines[['top', 'right', 'left', 'bottom']].set_visible(False)
    ax.tick_params(axis='y', left=False)
    ax.grid(False)

    plt.tight_layout()
    plt.show()


# --------------------------------------------------
# Pré-processamento dos dados
# --------------------------------------------------
categorias_interesse = ['alimentaçao e casa', 'gastos extra', 'roupas e calçados', 'bebida', 
                        'agua e luz', 'emprestimo', 'divida', 'saude']

df['category'] = df['category'].str.strip().str.lower()

df_filtered = df[
    (df['type'] == 'outcome') &
    (df['category'].isin(categorias_interesse))
].copy()

df_filtered['month'] = df_filtered['createdAt'].dt.to_period('M').dt.to_timestamp()
monthly_totals = df_filtered.groupby(['month', 'category'])['price'].sum().reset_index()

# Paleta de cores para categorias
palette = sns.color_palette("tab10", n_colors=len(categorias_interesse))
category_colors = dict(zip(categorias_interesse, palette))

# --------------------------------------------------
# Loop de categorias — um gráfico por vez
# --------------------------------------------------
for cat in categorias_interesse:
    dados = monthly_totals[monthly_totals['category'] == cat]
    plot_category(cat, dados, category_colors[cat])

```


## Receitas

### Quais são minhas principais fontes de receita?

```{python}
# Filtrar receitas
df_income = df[df['type'] == 'income'].copy()

# Agrupar por categoria
income_grouped = df_income.groupby('category')['price'].sum().sort_values(ascending=False).reset_index()

# Calcular porcentagem
income_grouped['percent'] = (income_grouped['price'] / income_grouped['price'].sum()) * 100

# Renomear colunas para exibir melhor
income_grouped.columns = ['Categoria', 'Total ', 'Porcentagem (%)']

# Arredondar valores
income_grouped['Total'] = income_grouped['Total '].round(2)
income_grouped['Porcentagem (%)'] = income_grouped['Porcentagem (%)'].round(1)

# Exibir tabela
show(income_grouped)
```

### Minha receita total aumentou ou diminuiu nos últimos meses?

```{python}
# Filtrar receitas
df_income = df[df['type'] == 'income'].copy()

# Agrupar por mês
df_income['month'] = df_income['createdAt'].dt.to_period('M').dt.to_timestamp()
monthly_income = df_income.groupby('month')['price'].sum().reset_index()

# Definir cores: cinza para todas as barras, azul para a última
colors = ['#d3d3d3'] * len(monthly_income)
colors[-1] = '#0077b6'  # Última barra azul

# Plot
plt.figure(figsize=(10, 3))

# Barras
plt.bar(monthly_income['month'], monthly_income['price'], 
        label='Receita Mensal', width=20, alpha=0.8, color=colors)

last_month = monthly_income.iloc[-1]
plt.text(
    x=last_month['month'], 
    y=last_month['price'] + (last_month['price'] * 0.02),  # ligeiro deslocamento acima da barra
    s=format_value_style(last_month['price']),
    ha='center', va='bottom', fontsize=10, fontweight='bold', color='#0077b6'
)


# Linha de tendência
plt.plot(monthly_income['month'], monthly_income['price'], 
         color='#0077b6', marker='o', linestyle='--', linewidth=1.5, label='Tendência')

# Eixos e título
plt.xlabel('Mês')
plt.ylabel('Receita Total')
plt.title('Evolução da Receita Mensal')
plt.xticks(rotation=45, ha='right')
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Formatando datas no eixo X
ax = plt.gca()
# Remove borders (spines)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_visible(False)
ax.spines['bottom'].set_visible(False)

ax.xaxis.set_major_locator(mdates.MonthLocator(interval=1))
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

plt.tight_layout()
plt.show()
```

## Orçamento e Metas

```{python}
# Definir orçamento mensal por categoria
budget = {
    'alimentaçao e casa': 3000,
    'roupas e calçados': 200,
    'bebida': 200,
    'agua e luz': 100,
    'emprestimos': 500,
    'dividas': 0,
    'lazer e convivio':1000,
    'agua e luz':300,
    'saude': 500
}
```

::: {layout-ncol="2"}

### Em quais categorias de orçamento estou estourando o limite com mais frequência?

```{python}
# Filtrar apenas os dados de despesas (type='outcome')
df_outcome = df[df['type'] == 'outcome'].copy()

# Adicionar uma coluna para o mês e ano
df_outcome['month_year'] = df_outcome['createdAt'].dt.to_period('M')

# Agrupar os dados por mês e categoria, somando os valores
monthly_expenses = df_outcome.groupby(['month_year', 'category'])['price'].sum().reset_index()

# Inicializar uma lista para armazenar as porcentagens de estouro por categoria
over_budget_percentages = []

# Iterar sobre cada categoria para calcular a porcentagem de meses em que o orçamento foi excedido
for category, limit in budget.items():
    # Filtrar os dados da categoria atual
    category_data = monthly_expenses[monthly_expenses['category'] == category]
    # Contar o número de meses em que o gasto excedeu o orçamento
    months_over_budget = (category_data['price'] > limit).sum()
    # Calcular o número total de meses registrados para a categoria
    total_months = category_data['month_year'].nunique()
    # Calcular a porcentagem de meses com estouro de orçamento
    percentage_over = (months_over_budget / total_months) * 100 if total_months > 0 else 0
    # Adicionar os resultados à lista
    over_budget_percentages.append({'Categoria': category, 'Percentual de Estouro (%)': round(percentage_over, 2)})

# Criar um DataFrame com os resultados
over_budget_df = pd.DataFrame(over_budget_percentages)

# Exibir a tabela
show(over_budget_df)
```

### Quanto ainda tenho disponível para gastar em cada categoria neste mês?

```{python}
# Filtrar despesas do mês atual
current_month_outcome = df[
    (df['type'] == 'outcome') &
    (df['createdAt'].dt.month == now.month) &
    (df['createdAt'].dt.year == now.year)
]

# Somar gastos por categoria neste mês
spent_by_category = current_month_outcome.groupby('category')['price'].sum()

# Calcular o restante do orçamento
remaining_budget = []

for category, limit in budget.items():
    spent = spent_by_category.get(category, 0)
    remaining = limit - spent
    remaining_budget.append({
        'categoria': category,
        'restou': round(remaining, 2)
    })

# Criar a tabela final
remaining_budget_df = pd.DataFrame(remaining_budget)
show(remaining_budget_df.sort_values(by='restou'))

```

:::

### Qual o meu progresso em relação à minha meta de economia?

```{python}
import matplotlib.pyplot as plt
import pandas as pd

# Adiciona colunas auxiliares
df['year'] = df['createdAt'].dt.year
df['month'] = df['createdAt'].dt.month

# Mapeia número do mês para nome abreviado em português
month_map = {
    1: 'jan', 2: 'fev', 3: 'mar', 4: 'abr',
    5: 'mai', 6: 'jun', 7: 'jul', 8: 'ago',
    9: 'set', 10: 'out', 11: 'nov', 12: 'dez'
}
df['month_name'] = df['month'].map(month_map)

# Soma receitas e despesas
income_by_month = df[df['type'] == 'income'].groupby(['year', 'month_name'])['price'].sum()
outcome_by_month = df[df['type'] == 'outcome'].groupby(['year', 'month_name'])['price'].sum()

# Calcula economia
economy_by_month = (income_by_month - outcome_by_month).reset_index(name='economy')

# Ordena meses
ordered_months = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez']
economy_by_month['month_name'] = pd.Categorical(economy_by_month['month_name'], categories=ordered_months, ordered=True)
economy_by_month = economy_by_month.sort_values(['year', 'month_name'])

# Gera um gráfico por ano
for year, data in economy_by_month.groupby('year'):
    fig, ax = plt.subplots(figsize=(14, 6))
    
    # Define cores
    colors = data['economy'].apply(lambda x: '#0077b6' if x >= 0 else '#f08585ff')
    
    # Cria gráfico horizontal
    ax.barh(data['month_name'], data['economy'], color=colors)
    
    # Linha central (zero)
    ax.axvline(0, color='black', linewidth=1)

    # Inverte ordem dos meses (jan em cima, dez embaixo)
    ax.invert_yaxis()
    
    # Remove eixos e bordas
    ax.tick_params(axis='x', labelbottom=False, bottom=False)
    for spine in ['top', 'right', 'left', 'bottom']:
        ax.spines[spine].set_visible(False)
    
    # Título
    ax.set_title(f'Economia mensal em {year}', fontsize=14, weight='bold')
    ax.set_ylabel('')  # Remove rótulo do eixo Y
    
    # Exibe valores formatados
    for i, v in enumerate(data['economy']):
        label = format_value_style(v)
        ax.text(v + (500 if v >= 0 else -500), i, label,
                color='black', va='center', ha='left' if v >= 0 else 'right', fontsize=9)
    
    plt.tight_layout()
    plt.show()
```

### Quanto estou conseguindo economizar em média por mês?

```{python}
# Adiciona colunas auxiliares
df['year'] = df['createdAt'].dt.year
df['month'] = df['createdAt'].dt.month

# Agrupa receitas e despesas por ano e mês
income = df[df['type'] == 'income'].groupby(['year', 'month'])['price'].sum()
outcome = df[df['type'] == 'outcome'].groupby(['year', 'month'])['price'].sum()

# Calcula economia mensal
economy = (income - outcome).reset_index()
economy.columns = ['year', 'month', 'economy']

# Ordena por ano e mês
economy = economy.sort_values(by=['year', 'month'])

# Filtra os últimos 3 meses disponíveis
last_three = economy.tail(3)

# Calcula média
average_saving = last_three['economy'].mean()

display(Markdown(f"Média de economia nos últimos 3 meses: **{average_saving:.2f}**"))
```

### Estou conseguindo seguir meu orçamento nesse mes?

```{python}
#| fig-align: center

# Filtrar o mês atual e tipo=outcome
df_outcome = df[df['type'] == 'outcome'].copy()
df_outcome['createdAt'] = pd.to_datetime(df_outcome['createdAt'], format='%d-%m-%Y')

now = datetime.now()

current_month = df_outcome[
    (df_outcome['createdAt'].dt.month == now.month) &
    (df_outcome['createdAt'].dt.year == now.year)
]

# Somar os gastos nas categorias selecionadas
selected_categories = list(budget.keys())
expense_sum = (
    current_month[current_month['category'].isin(selected_categories)]
    .groupby('category')['price']
    .sum()
    .reindex(selected_categories, fill_value=0)
)

# Preparar dados para o gráfico
labels = selected_categories
budget_values = [budget[cat] for cat in labels]
actual_values = [expense_sum[cat] for cat in labels]

# Criar o gráfico de barras empilhadas
x = np.arange(len(labels))
width = 0.5  # Largura da barra

fig, ax = plt.subplots(figsize=(8, 5))

# Calcular partes (restante e excesso)
remaining = []
over_budget = []

for actual, budget_value in zip(actual_values, budget_values):
    if actual > budget_value:
        remaining.append(0)
        over_budget.append(actual - budget_value)
    else:
        remaining.append(budget_value - actual)
        over_budget.append(0)

# Plotar gastos dentro do orçamento (vermelho claro)
ax.bar(x, np.minimum(actual_values, budget_values), width, color='#f08585ff', alpha=0.7, label='Gasto Atual')

# Plotar orçamento restante (azul)
ax.bar(x, remaining, width, bottom=np.minimum(actual_values, budget_values),
       color='#0077b6', alpha=0.4, label='Orçamento Restante')

# Plotar excesso (vermelho escuro)
ax.bar(x, over_budget, width, bottom=budget_values, color='#ad1010ff', alpha=0.9, label='Excesso')

# === Adicionar rótulos ===
for i, (actual, budget_value, excess, remain) in enumerate(zip(actual_values, budget_values, over_budget, remaining)):
    # Se há excesso, mostrar o valor excedente dentro da barra
    if excess > 0:
        ax.text(x[i], budget_value + excess / 2, f"+{excess:.0f}", ha='center', va='center',
                fontsize=8, color='white', fontweight='bold')

    # Valor restante (vertical, à direita da barra)
    if remain > 0:
        ax.text(
            x[i] + width / 2 + 0.05,   # desloca um pouco à direita
            (actual + budget_value) / 2,  # centraliza verticalmente
            f"{remain:.0f}",
            ha='left', va='center', rotation=90,
            fontsize=8, color='#0077b6', fontweight='bold'
        )
    else:
        # Se não há orçamento restante, mostra "0"
        ax.text(
            x[i] + width / 2 + 0.05,
            budget_value / 2,
            "",
            ha='left', va='center', rotation=90,
            fontsize=8, color='gray'
        )

# Estilo e rótulos
ax.set_title(f'Controle de Orçamento - {now.strftime("%B/%Y")}', fontsize=10)
ax.tick_params(axis='x', bottom=False)
for spine in ['top', 'right', 'left', 'bottom']:
    ax.spines[spine].set_visible(False)

ax.set_xticks(x)
ax.set_xticklabels(labels, rotation=45, ha='right')
ax.legend()

plt.tight_layout()
plt.show()
```

